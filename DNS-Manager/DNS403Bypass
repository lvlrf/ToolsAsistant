# 1) ساخت فایل 
cat > DNS403Bypass.sh <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

# =========================
# DNS Anti-403 Tester - v3.1 UPDATED
# Bug Fix: Selection now matches display order
# Added: 20+ privacy-focused DNS servers
# =========================

VERSION="3.1-updated"
BACKUP_DIR="/root/dns-backups"

TARGETS=(
  "Google|https://google.com"
  "GitHub|https://github.com"
  "DockerHub|https://registry-1.docker.io/v2/"
)

DNS_SERVERS=(
  # AdGuard DNS (Russia - Privacy-focused, No logs)
  "AdGuard-Default1|94.140.14.14"
  "AdGuard-Default2|94.140.15.15"
  "AdGuard-Family|94.140.14.15"
  "AdGuard-NonFilter1|94.140.14.140"
  "AdGuard-NonFilter2|94.140.14.141"
  "AdGuard-New1|94.140.14.49"
  "AdGuard-New2|94.140.14.59"
  
  # Quad9 (Switzerland - No logs, DNSSEC)
  "Quad9-Primary|9.9.9.9"
  "Quad9-Secondary|149.112.112.112"
  "Quad9-Unsecured|9.9.9.10"
  "Quad9-ECS|9.9.9.11"
  
  # Cloudflare (Privacy-focused)
  "Cloudflare-Primary|1.1.1.1"
  "Cloudflare-Secondary|1.0.0.1"
  "Cloudflare-Family1|1.1.1.3"
  "Cloudflare-Family2|1.0.0.3"
  "Cloudflare-NoMalware|1.1.1.2"
  
  # NextDNS (Privacy-focused, Customizable)
  "NextDNS-Primary|45.90.28.0"
  "NextDNS-Secondary|45.90.30.0"
  "NextDNS-Anycast1|45.90.28.167"
  "NextDNS-Anycast2|45.90.30.167"
  
  # Control D (Canada - Privacy-focused)
  "ControlD-Unfiltered1|76.76.2.0"
  "ControlD-Unfiltered2|76.76.10.0"
  "ControlD-BlockMalware1|76.76.2.1"
  "ControlD-BlockMalware2|76.76.10.1"
  
  # CleanBrowsing (Safe browsing)
  "CleanBrowsing-Security|185.228.168.9"
  "CleanBrowsing-Adult|185.228.168.10"
  "CleanBrowsing-Family|185.228.168.168"
  
  # OpenDNS (Cisco - Reliable)
  "OpenDNS-Home1|208.67.222.222"
  "OpenDNS-Home2|208.67.220.220"
  "OpenDNS-Family1|208.67.222.123"
  "OpenDNS-Family2|208.67.220.123"
  
  # DNS.SB (Privacy-focused, DNSSEC)
  "DNS.SB-Primary|185.222.222.222"
  "DNS.SB-Secondary|45.11.45.11"
  
  # Alternate DNS (No logs)
  "AlternateDNS1|76.76.19.19"
  "AlternateDNS2|76.223.122.150"
  
  # Comodo Secure DNS
  "Comodo-Primary|8.26.56.26"
  "Comodo-Secondary|8.20.247.20"
  
  # Verisign Public DNS
  "Verisign-Primary|64.6.64.6"
  "Verisign-Secondary|64.6.65.6"
  
  # BlahDNS (Privacy-focused, Multiple locations)
  "BlahDNS-Switzerland|45.91.92.121"
  "BlahDNS-Finland|95.216.212.177"
  "BlahDNS-Germany|78.46.244.143"
  "BlahDNS-Singapore|139.162.112.47"
  
  # Canadian Shield (CIRA)
  "CanadianShield-Private|149.112.121.10"
  "CanadianShield-Protected|149.112.121.20"
  "CanadianShield-Family|149.112.121.30"
  
  # Foundation for Applied Privacy (Austria)
  "Applied-Privacy|37.252.185.232"
  
  # CZ.NIC (Czech Republic)
  "CZ.NIC-Primary|193.17.47.1"
  "CZ.NIC-Secondary|185.43.135.1"
  
  # Hurricane Electric
  "HurricaneElectric|74.82.42.42"
  
  # puntCAT (Catalonia)
  "puntCAT|109.69.8.51"
  
  # German Privacy DNS
  "Digitale-Gesellschaft|185.95.218.42"
  "DNS-Privacy-DE|46.182.19.48"
  
  # Uncensored DNS (Denmark)
  "UncensoredDNS1|91.239.100.100"
  "UncensoredDNS2|89.233.43.71"
  
  # Iranian DNS (Anti-Sanctions)
  "Shecan1|178.22.122.100"
  "Shecan2|185.51.200.2"
  "Begzar1|185.55.226.26"
  "Begzar2|185.55.225.25"
  "Begzar3|185.55.224.24"
  "Electro1|78.157.42.100"
  "Electro2|78.157.42.101"
  "Radar1|10.202.10.10"
  "Radar2|10.202.10.11"
  "403online-1|10.202.10.202"
  "403online-2|10.202.10.102"
  


  # DynX (Iranian - Anti-Sanctions)
  "DynX-AntiSan1|10.139.177.18"
  "DynX-AntiSan2|10.139.177.16"
  "DynX-Vanilla1|10.139.177.21"
  "DynX-Vanilla2|10.139.177.22"
  "DynX-Adblock1|109.70.74.38"
  "DynX-Adblock2|109.70.74.68"


  "Beshkan1|181.41.194.177"
  "Beshkan2|181.41.194.186"


  "HostIran1|172.29.0.100"
  "HostIran2|172.29.2.100"
  "Moomni1|37.32.5.60"
  "Moomni2|37.32.5.61"
  
  # Google Public DNS (for comparison)
  "Google-Primary|8.8.8.8"
  "Google-Secondary|8.8.4.4"
)

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $*"; }
log_ok() { echo -e "${GREEN}[OK]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_skip() { echo -e "${CYAN}[SKIP]${NC} $*"; }

need_cmd(){ command -v "$1" >/dev/null 2>&1; }

ensure_deps() {
  local pkgs=()
  need_cmd curl || pkgs+=("curl")
  need_cmd dig  || pkgs+=("dnsutils")
  need_cmd resolvectl || pkgs+=("systemd")

  if [[ "${#pkgs[@]}" -gt 0 ]]; then
    log_info "Installing: ${pkgs[*]}"
    export DEBIAN_FRONTEND=noninteractive
    apt-get update -y >/dev/null 2>&1 || true
    apt-get install -y "${pkgs[@]}" >/dev/null 2>&1 || true
  fi
}

get_interface() {
  local iface=""
  iface="$(ip route show default 2>/dev/null | awk '{print $5}' | head -n1 || true)"
  if [[ -n "$iface" ]]; then
    echo "$iface"
    return 0
  fi
  return 1
}

check_dns_alive() {
  local dns_ip="$1"
  if timeout 3 dig +time=2 +tries=1 @"$dns_ip" google.com >/dev/null 2>&1; then
    return 0
  fi
  return 1
}

verdict() {
  case "$1" in
    200|204|301|302|307|308|401) echo "OK" ;;
    403) echo "BLOCK" ;;
    000) echo "FAIL" ;;
    *) echo "WARN" ;;
  esac
}

backup_dns() {
  mkdir -p "$BACKUP_DIR"
  local backup="$BACKUP_DIR/dns-state-$(date +%s).txt"
  if command -v resolvectl >/dev/null 2>&1; then
    resolvectl status > "$backup" 2>/dev/null || true
  fi
  echo "$backup"
}

restore_dns() {
  local iface="$1"
  local backup_dns="$2"
  
  if [[ -n "$iface" && -n "$backup_dns" ]]; then
    resolvectl dns "$iface" $backup_dns 2>/dev/null || true
    resolvectl domain "$iface" "~." 2>/dev/null || true
  fi
}

test_dns_proper() {
  local name="$1" dnsip="$2" iface="$3"
  local pass=0 block=0 fail=0

  resolvectl dns "$iface" "$dnsip" >/dev/null 2>&1
  resolvectl domain "$iface" "~." >/dev/null 2>&1
  
  sleep 2

  for t in "${TARGETS[@]}"; do
    label="${t%%|*}"
    url="${t#*|}"
    
    code=$(timeout 15 curl -sS -L --max-time 15 -o /dev/null \
      -w "%{http_code}" "$url" 2>/dev/null || echo "000")
    
    v=$(verdict "$code")
    case "$v" in
      OK) pass=$((pass+1)) ;;
      BLOCK) block=$((block+1)) ;;
      *) fail=$((fail+1)) ;;
    esac
  done

  local status="WEAK"
  if [[ $block -gt 0 ]]; then
    status="BLOCKED(403)"
  elif [[ $pass -eq ${#TARGETS[@]} ]]; then
    status="PERFECT"
  elif [[ $pass -ge $((${#TARGETS[@]}-1)) ]]; then
    status="GOOD"
  fi

  local score=$((block*10000 + fail*2000 + (${#TARGETS[@]}-pass)*500))
  echo "$score|$status|$name|$dnsip|$pass|$block|$fail"
}

run_test() {
  local ts=$(date +%F_%H%M%S)
  local OUT="/root/dns-anti403-${ts}.txt"
  
  local IFACE=""
  if ! IFACE=$(get_interface); then
    log_warn "Cannot detect network interface!"
    exit 1
  fi
  
  log_info "Detected interface: $IFACE"
  
  local CURRENT_DNS=""
  CURRENT_DNS=$(resolvectl status "$IFACE" 2>/dev/null | grep "DNS Servers" | head -1 | awk '{print $3, $4, $5, $6}' || echo "")
  log_info "Current DNS: $CURRENT_DNS"
  local backup_file=$(backup_dns)
  
  echo "=========================================="
  echo "   DNS Anti-403 Tester v$VERSION"
  echo "=========================================="
  echo
  log_info "Interface: $IFACE"
  log_info "Testing ${#DNS_SERVERS[@]} DNS servers"
  log_info "Backup: $backup_file"
  echo
  
  local tmp=$(mktemp)
  local tested=0
  local skipped=0
  local total="${#DNS_SERVERS[@]}"
  
  for item in "${DNS_SERVERS[@]}"; do
    name="${item%%|*}"
    dnsip="${item#*|}"
    
    echo -ne "\r${BLUE}[CHECK]${NC} $name ($dnsip)...                "
    
    if ! check_dns_alive "$dnsip"; then
      echo -e "\r${CYAN}[SKIP]${NC} $name ($dnsip) - Not reachable     "
      skipped=$((skipped+1))
      continue
    fi
    
    tested=$((tested+1))
    echo -ne "\r${BLUE}[$tested/$total]${NC} Testing $name ($dnsip)...     "
    
    result=$(test_dns_proper "$name" "$dnsip" "$IFACE")
    echo "$result" >> "$tmp"
    
    echo -e "\r${GREEN}[$tested/$total]${NC} Tested $name ($dnsip)        "
  done
  
  restore_dns "$IFACE" "$CURRENT_DNS"
  
  echo
  log_ok "Testing complete! Tested: $tested | Skipped: $skipped"
  echo
  
  # *** FIX: Create sorted file ***
  local tmp_sorted=$(mktemp)
  sort -t'|' -k1,1n "$tmp" > "$tmp_sorted"
  
  {
    echo "================================================================"
    echo "           DNS Anti-403 Test Results"
    echo "   Goal: Find DNS that bypasses 403 errors"
    echo "================================================================"
    echo "Time: $(date)"
    echo "Tested: $tested DNS | Skipped: $skipped"
    echo
    printf "%-4s %-16s %-24s %-18s %-3s %-3s %-3s\n" \
      "No" "STATUS" "DNS" "IP" "OK" "403" "FAIL"
    echo "--------------------------------------------------------------------"
    
    if [[ ! -s "$tmp_sorted" ]]; then
      echo "  No DNS servers were testable!"
    else
      i=0
      while IFS='|' read -r score status name ip ok b403 fail; do
        i=$((i+1))
        printf "%-4s %-16s %-24s %-18s %-3s %-3s %-3s\n" \
          "$i)" "$status" "$name" "$ip" "$ok" "$b403" "$fail"
      done < "$tmp_sorted"
    fi
    
    echo
    echo "Legend:"
    echo "  ✅ PERFECT: All tests passed - Bypasses 403!"
    echo "  ✅ GOOD: Minor issues, no 403"
    echo "  ❌ BLOCKED: Has 403 errors"
    echo "  ⚠️  WEAK: Multiple failures"
    echo
  } | tee "$OUT"
  
  log_ok "Report saved: $OUT"
  
  echo
  echo "Current DNS restored to: $CURRENT_DNS"
  echo
  
  # Interactive selection
  if [[ ! -s "$tmp_sorted" ]]; then
    log_warn "No DNS servers were testable. Exiting."
    rm -f "$tmp" "$tmp_sorted"
    return 0
  fi
  
  local total_tested=$(wc -l < "$tmp_sorted")
  
  echo "=========================================="
  echo " DNS Selection & Apply"
  echo "=========================================="
  echo
  echo "Select DNS to apply (or 0 to skip):"
  echo "  • Single: 1"
  echo "  • Primary + Secondary: 1,2"
  echo "  • Skip: 0"
  echo
  read -r -p "Your choice: " choice
  
  choice="$(echo "${choice:-}" | tr -d '[:space:]')"
  
  if [[ -z "$choice" || "$choice" == "0" ]]; then
    log_info "No changes made."
    rm -f "$tmp" "$tmp_sorted"
    return 0
  fi
  
  IFS=',' read -r idx1 idx2 <<<"$choice"
  
  if ! [[ "$idx1" =~ ^[0-9]+$ ]] || [[ "$idx1" -lt 1 ]] || [[ "$idx1" -gt "$total_tested" ]]; then
    log_warn "Invalid selection: $idx1"
    rm -f "$tmp" "$tmp_sorted"
    return 1
  fi
  
  # *** FIX: Use sorted file for selection ***
  dns1_line="$(sed -n "${idx1}p" "$tmp_sorted")"
  dns1_ip="$(echo "$dns1_line" | cut -d'|' -f4)"
  dns1_name="$(echo "$dns1_line" | cut -d'|' -f3)"
  dns1_status="$(echo "$dns1_line" | cut -d'|' -f2)"
  
  dns2_ip=""
  dns2_name=""
  dns2_status=""
  
  if [[ -n "${idx2:-}" ]]; then
    if ! [[ "$idx2" =~ ^[0-9]+$ ]] || [[ "$idx2" -lt 1 ]] || [[ "$idx2" -gt "$total_tested" ]]; then
      log_warn "Invalid secondary DNS: $idx2"
      rm -f "$tmp" "$tmp_sorted"
      return 1
    fi
    
    # *** FIX: Use sorted file ***
    dns2_line="$(sed -n "${idx2}p" "$tmp_sorted")"
    dns2_ip="$(echo "$dns2_line" | cut -d'|' -f4)"
    dns2_name="$(echo "$dns2_line" | cut -d'|' -f3)"
    dns2_status="$(echo "$dns2_line" | cut -d'|' -f2)"
  fi
  
  echo
  echo "=========================================="
  echo " Your Selection:"
  echo "=========================================="
  echo "  Primary DNS:"
  echo "    $idx1) $dns1_name ($dns1_ip) - $dns1_status"
  if [[ -n "$dns2_ip" ]]; then
    echo "  Secondary DNS:"
    echo "    $idx2) $dns2_name ($dns2_ip) - $dns2_status"
  fi
  echo "=========================================="
  echo
  
  if [[ "$dns1_status" == "BLOCKED(403)" ]] || [[ "$dns2_status" == "BLOCKED(403)" ]]; then
    log_warn "Warning: Selected DNS has 403 errors!"
    echo
  fi
  
  read -r -p "Apply these DNS settings? (y/n): " confirm
  confirm="${confirm,,}"
  
  if [[ "$confirm" != "y" ]]; then
    log_info "Cancelled."
    rm -f "$tmp" "$tmp_sorted"
    return 0
  fi
  
  echo
  log_info "Applying DNS..."
  
  if [[ -n "$dns2_ip" ]]; then
    resolvectl dns "$IFACE" "$dns1_ip" "$dns2_ip"
    log_ok "DNS set: $dns1_ip (primary), $dns2_ip (secondary)"
  else
    resolvectl dns "$IFACE" "$dns1_ip"
    log_ok "DNS set: $dns1_ip"
  fi
  
  resolvectl domain "$IFACE" "~."
  
  echo
  log_ok "DNS applied!"
  echo
  
  log_info "Current DNS:"
  resolvectl status "$IFACE" | grep -A 3 "DNS Servers"
  echo
  
  log_info "Testing..."
  echo -n "  • Google: "
  if curl -sS --max-time 5 -o /dev/null https://google.com 2>/dev/null; then
    echo -e "${GREEN}OK${NC}"
  else
    echo -e "${RED}FAIL${NC}"
  fi
  
  echo -n "  • GitHub: "
  code=$(curl -sS --max-time 10 -o /dev/null -w "%{http_code}" https://github.com 2>/dev/null || echo "000")
  if [[ "$code" == "200" ]]; then
    echo -e "${GREEN}OK${NC}"
  elif [[ "$code" == "403" ]]; then
    echo -e "${RED}BLOCKED (403)${NC}"
  else
    echo -e "${YELLOW}HTTP $code${NC}"
  fi
  
  echo -n "  • Docker: "
  code=$(curl -sS --max-time 10 -o /dev/null -w "%{http_code}" https://registry-1.docker.io/v2/ 2>/dev/null || echo "000")
  if [[ "$code" == "401" ]]; then
    echo -e "${GREEN}OK (401)${NC}"
  elif [[ "$code" == "403" ]]; then
    echo -e "${RED}BLOCKED (403)${NC}"
  else
    echo -e "${YELLOW}HTTP $code${NC}"
  fi
  
  echo
  
  # Permanent option
  echo "=========================================="
  echo " Make DNS Permanent?"
  echo "=========================================="
  echo
  read -r -p "Make DNS permanent? (y/n): " make_permanent
  make_permanent="${make_permanent,,}"
  
  if [[ "$make_permanent" == "y" ]]; then
    echo
    log_info "Making DNS permanent..."
    
    if [[ -f /etc/systemd/resolved.conf ]]; then
      cp /etc/systemd/resolved.conf /etc/systemd/resolved.conf.backup.$(date +%s)
      log_ok "Backed up config"
    fi
    
    if grep -q "^\[Resolve\]" /etc/systemd/resolved.conf 2>/dev/null; then
      sed -i '/^DNS=/d' /etc/systemd/resolved.conf
      sed -i '/^Domains=/d' /etc/systemd/resolved.conf
      
      if [[ -n "$dns2_ip" ]]; then
        sed -i "/^\[Resolve\]/a DNS=$dns1_ip $dns2_ip" /etc/systemd/resolved.conf
      else
        sed -i "/^\[Resolve\]/a DNS=$dns1_ip" /etc/systemd/resolved.conf
      fi
      sed -i "/^\[Resolve\]/a Domains=~." /etc/systemd/resolved.conf
    else
      {
        echo ""
        echo "[Resolve]"
        if [[ -n "$dns2_ip" ]]; then
          echo "DNS=$dns1_ip $dns2_ip"
        else
          echo "DNS=$dns1_ip"
        fi
        echo "Domains=~."
      } >> /etc/systemd/resolved.conf
    fi
    
    log_ok "Config updated"
    
    systemctl restart systemd-resolved
    sleep 2
    
    log_ok "DNS is now permanent!"
    
  else
    echo
    log_info "DNS is temporary (will reset after reboot)"
  fi
  
  echo
  echo "=========================================="
  echo " Setup Complete!"
  echo "=========================================="
  
  rm -f "$tmp" "$tmp_sorted"
}

if [[ $EUID -ne 0 ]]; then
  log_warn "Recommended to run with sudo"
  read -p "Continue? (y/n): " yn
  [[ "${yn,,}" != "y" ]] && exit 1
fi

if ! systemctl is-active --quiet systemd-resolved; then
  log_warn "systemd-resolved is not active!"
  exit 1
fi

ensure_deps
run_test
EOF

# 2) دادن مجوز اجرا (به‌جای 777، حالت امن‌تر)
chmod +x DNS403Bypass.sh

# 3) اجرا با sudo
sudo ./DNS403Bypass.sh
