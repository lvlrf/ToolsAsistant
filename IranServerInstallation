cat > IranServerInstallation.sh <<'__SCRIPT__'
#!/usr/bin/env bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive

# =============================
# IranServerInstallation.sh - Offline Kit Builder (Hardened)
# - Safe APT install with self-heal and conflict handling
# - Docker via get.docker.com (as requested)
# - Pull & save Docker images for offline use
# - Clone GitHub repos
# - Write offline docker-compose
#
# Options (env):
#   KIT_ROOT=/opt/offline-kit
#   ENABLE_IPERF3_SERVICE=1   # default 1
# =============================

KIT_ROOT="${KIT_ROOT:-/opt/offline-kit}"
ENABLE_IPERF3_SERVICE="${ENABLE_IPERF3_SERVICE:-1}"

IMAGES_DIR="$KIT_ROOT/docker-images"
REPOS_DIR="$KIT_ROOT/repos"
LOG_DIR="$KIT_ROOT/logs"
META_DIR="$KIT_ROOT/meta"
COMPOSE_DIR="$KIT_ROOT/compose"

mkdir -p "$IMAGES_DIR" "$REPOS_DIR" "$LOG_DIR" "$META_DIR" "$COMPOSE_DIR"

log(){ echo "[+] $*" | tee -a "$LOG_DIR/offline-kit.log" >/dev/null; }
warn(){ echo "[!] $*" | tee -a "$LOG_DIR/offline-kit.log" >/dev/null; }
die(){ echo "[X] $*" | tee -a "$LOG_DIR/offline-kit.log" >/dev/null; exit 1; }
run(){ "$@" 2>&1 | tee -a "$LOG_DIR/offline-kit.log"; }

require_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    die "این اسکریپت باید با root اجرا شود: sudo bash IranServerInstallation.sh"
  fi
}

detect_ubuntu() {
  [[ -f /etc/os-release ]] || die "os-release پیدا نشد."
  # shellcheck disable=SC1091
  . /etc/os-release
  echo "${VERSION_CODENAME:-}" > "$META_DIR/ubuntu_codename.txt"
  if [[ "${ID:-}" != "ubuntu" ]]; then
    warn "این اسکریپت برای Ubuntu نوشته شده. ID=$ID"
  fi
}

apt_heal() {
  # ترمیم وضعیت APT/DPKG در صورت نیمه‌نصب/خرابی
  apt-get update -y || true
  dpkg --configure -a || true
  apt-get -f install -y || true
}

unhold_if_any() {
  local holds
  holds="$(apt-mark showhold 2>/dev/null || true)"
  if [[ -n "${holds}" ]]; then
    warn "Held packages detected. Unholding..."
    while read -r p; do
      [[ -n "$p" ]] && apt-mark unhold "$p" || true
    done <<< "$holds"
  fi
}

apt_install_safe() {
  # نصب ایمن: چند مرحله تلاش + self-heal
  local pkgs=("$@")

  unhold_if_any
  apt_heal

  if apt-get install -y "${pkgs[@]}"; then
    return 0
  fi

  warn "apt install failed. Trying heal + retry..."
  apt_heal

  if apt-get install -y "${pkgs[@]}"; then
    return 0
  fi

  return 1
}

apt_prep() {
  log "APT prep: update + base certs/tools (openssl/ca-certificates first)"
  run apt-get update -y
  # طبق خواسته تو
  run apt-get install -y --no-install-recommends openssl ca-certificates curl wget git gnupg lsb-release tzdata
  run update-ca-certificates || true
}

install_tools() {
  log "Installing network/system tools (safe mode)..."

  # ابزارهای اصلی (کم‌ریسک‌تر)
  local core_pkgs=(
    net-tools iproute2 iptables
    iputils-ping traceroute mtr tcpdump nmap
    iftop nethogs bmon bridge-utils
    dnsutils bind9-utils whois
    openssh-server fail2ban
    unzip zip tar
    screen tmux vim htop iotop ncdu jq ripgrep
    snapd flatpak
    ethtool socat netcat-openbsd
    iperf3
    rsync cron
    python3 python3-venv python3-pip
    haproxy nginx
    strongswan strongswan-swanctl
    wireguard wireguard-tools resolvconf
    openvpn
  )

  if ! apt_install_safe "${core_pkgs[@]}"; then
    die "Core packages install failed even after heal."
  fi

  # UFW فقط نصب شود (فعال نشود)
  if ! apt_install_safe ufw; then
    warn "ufw install failed. Continuing without ufw."
  else
    # تاکید: فعال‌سازی انجام نمی‌دهیم
    warn "ufw installed but NOT enabled (as requested)."
  fi

  # iptables-persistent/netfilter-persistent را جدا نصب می‌کنیم چون ممکن است conflict داشته باشد
  if ! apt_install_safe iptables-persistent netfilter-persistent; then
    warn "iptables-persistent/netfilter-persistent conflict detected. Applying auto-fix..."
    apt-get remove -y iptables-persistent netfilter-persistent || true
    apt_heal
    warn "Continuing WITHOUT iptables-persistent. You can enable persistence later if needed."
  fi

  printf "%s\n" "${core_pkgs[@]}" ufw iptables-persistent netfilter-persistent > "$META_DIR/installed_packages_requested.txt"
}

ensure_iperf3_service() {
  # اگر ENABLE_IPERF3_SERVICE=1 باشد، iperf3 را به صورت سرویس دائمی فعال می‌کند
  [[ "$ENABLE_IPERF3_SERVICE" == "1" ]] || { warn "iperf3 service disabled by env (ENABLE_IPERF3_SERVICE=0)."; return 0; }

  command -v iperf3 >/dev/null 2>&1 || { warn "iperf3 not installed; skipping service."; return 0; }

  if systemctl list-unit-files 2>/dev/null | awk '{print $1}' | grep -qx 'iperf3.service'; then
    log "Enabling existing iperf3.service"
    systemctl enable --now iperf3.service || true
    return 0
  fi

  log "Creating and enabling iperf3.service"
  cat >/etc/systemd/system/iperf3.service <<'EOF'
[Unit]
Description=iperf3 server
After=network-online.target
Wants=network-online.target

[Service]
ExecStart=/usr/bin/iperf3 -s
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload || true
  systemctl enable --now iperf3.service || true
}

install_docker() {
  log "Installing Docker via get.docker.com (requested path)"
  # تضمین پیش‌نیازها
  apt_install_safe openssl ca-certificates curl || true

  run curl -fsSL --retry 5 --retry-delay 2 https://get.docker.com -o /tmp/get-docker.sh
  run sh /tmp/get-docker.sh

  run systemctl enable --now docker
  run docker --version || die "Docker نصب نشد."
  run docker compose version || true
}

write_sample_compose() {
  log "Writing sample compose to $COMPOSE_DIR/docker-compose.offline.yml"

  cat > "$COMPOSE_DIR/docker-compose.offline.yml" <<'YML'
version: '3.8'

services:
  netdata:
    image: netdata/netdata:latest
    container_name: netdata
    restart: unless-stopped
    ports: ["19999:19999"]
    cap_add: [SYS_PTRACE]
    security_opt: [apparmor:unconfined]
    volumes:
      - netdataconfig:/etc/netdata
      - netdatalib:/var/lib/netdata
      - netdatacache:/var/cache/netdata
      - /etc/passwd:/host/etc/passwd:ro
      - /etc/group:/host/etc/group:ro
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /etc/os-release:/host/etc/os-release:ro

  librespeed:
    image: linuxserver/librespeed:latest
    container_name: librespeed
    restart: unless-stopped
    ports: ["8081:80"]
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Asia/Tehran

  iperf3:
    image: networkstatic/iperf3:latest
    container_name: iperf3
    restart: unless-stopped
    ports:
      - "5201:5201/tcp"
      - "5201:5201/udp"
    command: -s

  pihole:
    image: pihole/pihole:latest
    container_name: pihole
    restart: unless-stopped
    ports:
      - "53:53/tcp"
      - "53:53/udp"
      - "8053:80/tcp"
    environment:
      - TZ=Asia/Tehran
      - WEBPASSWORD=change-me
    volumes:
      - ./pihole/etc-pihole:/etc/pihole
      - ./pihole/etc-dnsmasq.d:/etc/dnsmasq.d

  frps:
    image: snowdreamtech/frps:latest
    container_name: frps
    restart: unless-stopped
    ports:
      - "7000:7000"
      - "7500:7500"
    volumes:
      - ./frps/frps.ini:/etc/frp/frps.ini

  nginx:
    image: nginx:alpine
    container_name: nginx
    restart: unless-stopped
    ports: ["80:80", "443:443"]
    volumes:
      - ./nginx/html:/usr/share/nginx/html
      - ./nginx/conf.d:/etc/nginx/conf.d

  mariadb:
    image: mariadb:10.11
    container_name: mariadb
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: change-me
      MYSQL_DATABASE: appdb
    ports: ["3306:3306"]
    volumes:
      - ./mariadb/data:/var/lib/mysql
      - ./mariadb/init:/docker-entrypoint-initdb.d

  postgres:
    image: postgres:16-alpine
    container_name: postgres
    restart: unless-stopped
    environment:
      POSTGRES_PASSWORD: change-me
      POSTGRES_DB: appdb
    ports: ["5432:5432"]
    volumes:
      - ./postgres/data:/var/lib/postgresql/data

  redis:
    image: redis:alpine
    container_name: redis
    restart: unless-stopped
    ports: ["6379:6379"]
    volumes:
      - ./redis/data:/data

  phpmyadmin:
    image: phpmyadmin:latest
    container_name: phpmyadmin
    restart: unless-stopped
    ports: ["8082:80"]
    environment:
      - PMA_HOST=mariadb

  portainer:
    image: portainer/portainer-ce:latest
    container_name: portainer
    restart: unless-stopped
    ports: ["9000:9000"]
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainerdata:/data

volumes:
  netdatoconfig:
  netdatalib:
  netdatacache:
  portainerdata:
YML

  # توجه: یک تایپو کوچک را برای جلوگیری از error در volumes اصلاح می‌کنیم
  # بعضی composeها به نام دقیق volume حساس‌اند.
  sed -i 's/netdatoconfig:/netdataconfig:/g' "$COMPOSE_DIR/docker-compose.offline.yml"
}

clone_repos() {
  log "Cloning GitHub repos..."
  local repos=(
    "https://github.com/Musixal/Backhaul"
    "https://github.com/zZedix/Smite"
    "https://github.com/alireza0/x-ui"
    "https://github.com/MHSanaei/3x-ui"
  )
  printf "%s\n" "${repos[@]}" > "$META_DIR/github_repos_requested.txt"

  for url in "${repos[@]}"; do
    local name dest
    name="$(basename "$url" .git)"
    dest="$REPOS_DIR/$name"

    if [[ -d "$dest/.git" ]]; then
      log "Repo exists, pulling: $name"
      (cd "$dest" && git pull --ff-only) || warn "git pull failed: $name"
    else
      log "Cloning: $url -> $dest"
      git clone --depth 1 "$url" "$dest" || warn "git clone failed: $name"
    fi
  done
}

pull_and_save_images() {
  log "Pulling and saving core Docker images..."
  local images=(
    "netdata/netdata:latest"
    "linuxserver/librespeed:latest"
    "networkstatic/iperf3:latest"
    "pihole/pihole:latest"
    "snowdreamtech/frps:latest"
    "nginx:alpine"
    "mariadb:10.11"
    "postgres:16-alpine"
    "redis:alpine"
    "phpmyadmin:latest"
    "portainer/portainer-ce:latest"
    "ghcr.io/xtls/xray-core:latest"
    "teddysun/xray:latest"
    "metacubex/mihomo:latest"
    "gozargah/marzban:latest"
  )
  printf "%s\n" "${images[@]}" > "$META_DIR/docker_images_requested.txt"

  for img in "${images[@]}"; do
    log "Pull: $img"
    docker pull "$img" || warn "Pull failed: $img"
  done

  local ts tarpath
  ts="$(date +%Y%m%d-%H%M%S)"
  tarpath="$IMAGES_DIR/core-images-$ts.tar"

  local present=()
  for img in "${images[@]}"; do
    docker image inspect "$img" >/dev/null 2>&1 && present+=("$img")
  done

  if [[ "${#present[@]}" -gt 0 ]]; then
    log "docker save -> $tarpath"
    run docker save -o "$tarpath" "${present[@]}"
    run sha256sum "$tarpath" > "$tarpath.sha256"
  else
    warn "No images available locally to save."
  fi
}

print_next_steps() {
  cat <<EOF

========================================
Offline kit آماده شد در:
  $KIT_ROOT

خروجی‌ها:
  - Docker image tar files:
      $IMAGES_DIR/*.tar
  - Git repos:
      $REPOS_DIR/
  - Sample compose:
      $COMPOSE_DIR/docker-compose.offline.yml
  - Logs:
      $LOG_DIR/offline-kit.log

برای استفاده آفلاین:
  1) docker load -i $IMAGES_DIR/core-images-*.tar
  2) cd $COMPOSE_DIR && docker compose -f docker-compose.offline.yml up -d

نکته:
  - ufw فقط نصب شده و فعال نشده (طبق درخواست شما).
  - اگر نمی‌خواهید سرویس iperf3 فعال شود:
      ENABLE_IPERF3_SERVICE=0 sudo bash IranServerInstallation.sh
========================================
EOF
}

main() {
  require_root
  detect_ubuntu
  apt_prep
  install_tools
  ensure_iperf3_service
  install_docker
  write_sample_compose
  clone_repos
  pull_and_save_images
  print_next_steps
  log "Done."
}

main "$@"

__SCRIPT__

chmod +x IranServerInstallation.sh
sudo bash ./IranServerInstallation.sh
